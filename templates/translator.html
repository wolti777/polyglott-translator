{% extends "base.html" %}

{% block title %}Glossarium{% endblock %}

{% block content %}
<div class="app-container">
    <header class="app-header">
        <div class="logo">
            <span class="logo-icon">üìö</span>
            <h1>Glossarium</h1>
        </div>
        <div class="header-actions">
            <a href="/glossary-list" class="btn btn-outline export-btn" title="Vokabelliste">Liste</a>
            <a href="/vocab-test" class="btn btn-outline export-btn" title="Vokabeltest">Test</a>
            <button id="settings-btn" class="btn btn-outline settings-btn" title="Einstellungen">‚öôÔ∏è</button>
            <a href="#" id="export-glossary-btn" class="btn btn-outline export-btn" title="Glossar exportieren">Export</a>
            <div class="glossary-wrapper">
                <button class="btn btn-secondary glossary-btn">
                    <span id="selected-glossary-name">Hauptglossar</span>
                </button>
                <button class="btn btn-secondary glossary-toggle" id="glossary-menu-btn" title="Glossar wechseln">‚ñº</button>
                <div class="glossary-menu" id="glossary-dropdown">
                    <div class="glossary-menu-header">Glossar ausw√§hlen</div>
                    <div class="glossary-list" id="glossary-list"></div>
                    <div class="glossary-create-row">
                        <input type="text" id="new-glossary-name" placeholder="Neues Glossar...">
                        <button id="create-glossary-btn">+</button>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <main class="translator-main">
        <div class="input-section">
            <div class="input-row">
                <textarea id="input-text" placeholder="Text eingeben..." rows="3"></textarea>
                <div class="input-actions">
                    <button id="camera-btn" class="camera-btn" title="Kamera √∂ffnen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                            <circle cx="12" cy="13" r="4"></circle>
                        </svg>
                    </button>
                    <div class="language-selector" id="language-selector">
                        <span id="selected-language-flag">üá©üá™</span>
                        <span class="dropdown-arrow">‚ñº</span>
                        <div class="language-dropdown" id="language-dropdown">
                            <!-- Populated dynamically based on settings -->
                        </div>
                    </div>
                </div>
            </div>
            <button id="translate-btn" class="btn btn-primary btn-large">√úbersetzen von&nbsp;<span id="selected-language-text">German</span></button>
        </div>

        <!-- Camera Overlay -->
        <div id="camera-overlay" class="camera-overlay" style="display: none;">
            <div class="camera-header">
                <span>Richte den Rahmen auf das Wort</span>
                <button id="camera-close" class="camera-close-btn">‚úï</button>
            </div>
            <div class="camera-container">
                <video id="camera-video" autoplay playsinline></video>
                <canvas id="camera-canvas"></canvas>
                <!-- Scan Frame -->
                <div class="scan-frame-overlay">
                    <div class="scan-frame-top"></div>
                    <div class="scan-frame-middle">
                        <div class="scan-frame-left"></div>
                        <div class="scan-frame" id="scan-frame">
                            <div class="scan-corner scan-corner-tl"></div>
                            <div class="scan-corner scan-corner-tr"></div>
                            <div class="scan-corner scan-corner-bl"></div>
                            <div class="scan-corner scan-corner-br"></div>
                        </div>
                        <div class="scan-frame-right"></div>
                    </div>
                    <div class="scan-frame-bottom">
                        <button id="camera-capture" class="btn btn-primary scan-btn">Scannen</button>
                    </div>
                </div>
            </div>
            <div class="camera-result">
                <div class="scanned-words-label">Erkannte W√∂rter (tippe zum Ausw√§hlen):</div>
                <div id="scanned-words" class="scanned-words"></div>
                <div class="selected-preview">
                    <span class="selected-label">Auswahl:</span>
                    <span id="selected-preview-text">---</span>
                </div>
            </div>
            <div class="camera-actions">
                <div class="camera-lang-label">√úbersetzen von:</div>
                <div class="camera-lang-buttons">
                    <!-- Populated dynamically based on settings -->
                </div>
            </div>
            <div id="camera-status" class="camera-status">W√∂rter scannen, ausw√§hlen, dann Quellsprache w√§hlen</div>
        </div>

        <!-- Settings Modal -->
        <div id="settings-modal" class="settings-modal" style="display: none;">
            <div class="settings-modal-content">
                <div class="settings-header">
                    <h2>‚öôÔ∏è Einstellungen</h2>
                    <button id="settings-close" class="settings-close-btn">‚úï</button>
                </div>
                <div class="settings-body">
                    <div class="settings-section">
                        <h3>SPRACHEN</h3>
                        <p class="settings-hint">W√§hle 2‚Äì6 Sprachen in gew√ºnschter Reihenfolge</p>
                        <div class="settings-languages">
                            <div class="settings-language-row">
                                <span class="lang-number">1.</span>
                                <select id="settings-lang-1" class="settings-language-select"></select>
                            </div>
                            <div class="settings-language-row">
                                <span class="lang-number">2.</span>
                                <select id="settings-lang-2" class="settings-language-select"></select>
                            </div>
                            <div class="settings-language-row">
                                <span class="lang-number">3.</span>
                                <select id="settings-lang-3" class="settings-language-select"></select>
                            </div>
                            <div class="settings-language-row">
                                <span class="lang-number">4.</span>
                                <select id="settings-lang-4" class="settings-language-select"></select>
                            </div>
                            <div class="settings-language-row">
                                <span class="lang-number">5.</span>
                                <select id="settings-lang-5" class="settings-language-select"></select>
                            </div>
                            <div class="settings-language-row">
                                <span class="lang-number">6.</span>
                                <select id="settings-lang-6" class="settings-language-select"></select>
                            </div>
                        </div>
                    </div>
                    <div class="settings-divider"></div>
                    <div class="settings-section">
                        <h3>√úBERSETZUNGSDIENSTE</h3>
                        <div class="settings-checkboxes">
                            <label class="settings-checkbox">
                                <input type="checkbox" id="service-deepl" checked>
                                <span class="checkmark"></span>
                                DeepL
                            </label>
                            <label class="settings-checkbox">
                                <input type="checkbox" id="service-pons" checked>
                                <span class="checkmark"></span>
                                PONS
                            </label>
                            <label class="settings-checkbox">
                                <input type="checkbox" id="service-google" checked>
                                <span class="checkmark"></span>
                                Google
                            </label>
                            <label class="settings-checkbox">
                                <input type="checkbox" id="service-lingva">
                                <span class="checkmark"></span>
                                Lingva
                            </label>
                        </div>
                    </div>
                    <div class="settings-divider"></div>
                    <div class="settings-section">
                        <h3>ERKL√ÑRUNGEN</h3>
                        <div class="settings-checkboxes">
                            <label class="settings-checkbox">
                                <input type="checkbox" id="explain-pons" checked>
                                <span class="checkmark"></span>
                                PONS W√∂rterbuch
                            </label>
                            <label class="settings-checkbox">
                                <input type="checkbox" id="explain-groq" checked>
                                <span class="checkmark"></span>
                                KI (Groq)
                            </label>
                        </div>
                    </div>
                    <div class="settings-divider"></div>
                    <div class="settings-section">
                        <h3>API-SCHL√úSSEL</h3>
                        <p class="settings-hint" id="api-keys-hint">Eigene API-Keys eintragen (optional)</p>
                        <div class="api-keys-fields">
                            <div class="api-key-row">
                                <label class="api-key-label">DeepL</label>
                                <div class="api-key-input-wrapper">
                                    <input type="text" id="apikey-deepl" class="api-key-input" placeholder="Kein Key">
                                    <button class="api-key-delete" data-service="deepl" title="Key l√∂schen">&times;</button>
                                </div>
                            </div>
                            <div class="api-key-row">
                                <label class="api-key-label">PONS</label>
                                <div class="api-key-input-wrapper">
                                    <input type="text" id="apikey-pons" class="api-key-input" placeholder="Kein Key">
                                    <button class="api-key-delete" data-service="pons" title="Key l√∂schen">&times;</button>
                                </div>
                            </div>
                            <div class="api-key-row">
                                <label class="api-key-label">Google</label>
                                <div class="api-key-input-wrapper">
                                    <input type="text" id="apikey-google" class="api-key-input" placeholder="Kein Key">
                                    <button class="api-key-delete" data-service="google" title="Key l√∂schen">&times;</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="settings-divider"></div>
                    <div class="settings-section">
                        <h3>KONTO</h3>
                        <div class="settings-account-links">
                            <a href="/change-password" class="btn btn-outline settings-account-btn">Passwort √§ndern</a>
                            <a href="/admin/dashboard" class="btn btn-outline settings-account-btn" id="admin-dashboard-link" style="display:none">Admin Dashboard</a>
                        </div>
                    </div>
                </div>
                <div class="settings-footer">
                    <button id="settings-cancel" class="btn btn-outline">Abbrechen</button>
                    <button id="settings-save" class="btn btn-primary">Speichern</button>
                </div>
            </div>
        </div>

        <div class="explanation-boxes">
            <div id="ai-explanation-box" class="ai-explanation-box" style="display: none;">
                <div class="ai-explanation-header">
                    <span class="ai-icon">üìñ</span>
                    <span>PONS</span>
                </div>
                <div id="ai-explanation-content"></div>
            </div>
            <div id="groq-explanation-box" class="groq-explanation-box" style="display: none;">
                <div class="groq-explanation-header">
                    <span class="groq-icon">ü§ñ</span>
                    <span>KI</span>
                </div>
                <div id="groq-explanation-content"></div>
            </div>
        </div>

        <div id="translations-container" class="translations-grid-3" style="display: none;">

            <!-- Translation boxes will be dynamically generated -->
        </div>

        <div id="selection-status" class="selection-status" style="display: none;">
            <span id="selection-count">0/3</span> selected
        </div>

        <div id="recent-saves" class="recent-saves" style="display: none;">
            <div class="recent-saves-header">
                <h3>Recent Saves</h3>
                <span class="recent-saves-glossary">Glossar: <span id="recent-glossary-name">-</span></span>
            </div>
            <div id="recent-saves-list" class="recent-saves-list"></div>
            <a href="#" id="export-glossary-btn-bottom" class="btn btn-outline export-btn-bottom">Export: <span id="export-glossary-name">-</span></a>
        </div>

        <footer class="app-footer">
            <a href="/logout" class="btn btn-outline">Logout</a>
        </footer>
    </main>
</div>
{% endblock %}

{% block scripts %}
<script>
    const inputText = document.getElementById('input-text');
    const translateBtn = document.getElementById('translate-btn');
    const languageSelector = document.getElementById('language-selector');
    const languageDropdown = document.getElementById('language-dropdown');
    const selectedLanguageFlag = document.getElementById('selected-language-flag');
    const selectedLanguageText = document.getElementById('selected-language-text');
    const translationsContainer = document.getElementById('translations-container');
    const selectionStatus = document.getElementById('selection-status');
    const selectionCount = document.getElementById('selection-count');
    const aiExplanationBox = document.getElementById('ai-explanation-box');
    const aiExplanationContent = document.getElementById('ai-explanation-content');
    const groqExplanationBox = document.getElementById('groq-explanation-box');
    const groqExplanationContent = document.getElementById('groq-explanation-content');

    // Glossary elements
    const glossaryMenuBtn = document.getElementById('glossary-menu-btn');
    const glossaryDropdown = document.getElementById('glossary-dropdown');
    const glossaryList = document.getElementById('glossary-list');
    const selectedGlossaryName = document.getElementById('selected-glossary-name');
    const newGlossaryInput = document.getElementById('new-glossary-name');
    const createGlossaryBtn = document.getElementById('create-glossary-btn');
    const exportGlossaryBtn = document.getElementById('export-glossary-btn');
    const exportGlossaryBtnBottom = document.getElementById('export-glossary-btn-bottom');
    const recentGlossaryName = document.getElementById('recent-glossary-name');
    const exportGlossaryName = document.getElementById('export-glossary-name');

    // Per-user storage keys
    const currentUsername = '{{ user.username }}';
    const currentUserId = {{ user.id }};
    const storageKey = (key) => key + '_' + currentUsername;

    // All available languages
    const allLanguages = {
        'german': { name: 'Deutsch', flag: 'üá©üá™', code: 'de' },
        'english': { name: 'English', flag: 'üá¨üáß', code: 'en' },
        'spanish': { name: 'Espa√±ol', flag: 'üá™üá∏', code: 'es' },
        'polish': { name: 'Polski', flag: 'üáµüá±', code: 'pl' },
        'french': { name: 'Fran√ßais', flag: 'üá´üá∑', code: 'fr' },
        'italian': { name: 'Italiano', flag: 'üáÆüáπ', code: 'it' },
        'portuguese': { name: 'Portugu√™s', flag: 'üáµüáπ', code: 'pt' },
        'dutch': { name: 'Nederlands', flag: 'üá≥üá±', code: 'nl' },
        'russian': { name: '–†—É—Å—Å–∫–∏–π', flag: 'üá∑üá∫', code: 'ru' },
    };

    // Default settings
    const defaultSettings = {
        languages: [],
        translationServices: {
            'DeepL': true,
            'PONS': true,
            'Google': true,
            'Lingva': false
        },
        explanationServices: {
            'PONS Definition': true,
            'Groq AI': true
        }
    };

    // Load settings from localStorage (per-user), then sync from DB
    function loadSettings() {
        const saved = localStorage.getItem(storageKey('glossariumSettings'));
        if (saved) {
            try {
                return JSON.parse(saved);
            } catch (e) {
                console.error('Failed to parse settings:', e);
            }
        }
        return { ...defaultSettings };
    }

    // Save settings to localStorage and DB
    function saveSettingsToStorage(settings) {
        localStorage.setItem(storageKey('glossariumSettings'), JSON.stringify(settings));
        // Also save to DB for cross-device sync
        fetch('/user/settings', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({language_config: JSON.stringify(settings)})
        }).then(r => {
            if (!r.ok) console.error('Settings DB save failed:', r.status);
            else console.log('Settings saved to DB');
        }).catch(e => console.error('Failed to sync settings to DB:', e));
    }

    // Load settings from DB (cross-device sync)
    async function syncSettingsFromDB() {
        try {
            const resp = await fetch('/user/settings');
            if (resp.ok) {
                const data = await resp.json();
                if (data.language_config && data.language_config.length > 2) {
                    const dbSettings = JSON.parse(data.language_config);
                    if (dbSettings && dbSettings.languages && dbSettings.languages.length >= 2) {
                        localStorage.setItem(storageKey('glossariumSettings'), JSON.stringify(dbSettings));
                        return dbSettings;
                    }
                }
            }
        } catch (e) {
            console.error('Failed to load settings from DB:', e);
        }
        return null;
    }

    // Current settings
    let appSettings = loadSettings();

    let currentData = null;
    let recentSaves = [];
    let selectedLanguage = localStorage.getItem(storageKey('selectedLanguage')) || (appSettings.languages.length > 0 ? appSettings.languages[0] : 'german');
    if (selectedLanguage === 'auto') selectedLanguage = appSettings.languages[0] || 'german';
    let selections = {};
    let glossaries = [];
    let selectedGlossaryId = localStorage.getItem(storageKey('selectedGlossaryId')) || null;

    // Dynamic language mappings based on settings
    const languageNames = {};
    const languageFlags = {};

    function updateLanguageMappings() {
        // Clear existing
        Object.keys(languageNames).forEach(k => delete languageNames[k]);
        Object.keys(languageFlags).forEach(k => delete languageFlags[k]);

        // Add from settings
        appSettings.languages.forEach(lang => {
            if (allLanguages[lang]) {
                languageNames[lang] = allLanguages[lang].name;
                languageFlags[lang] = allLanguages[lang].flag;
            }
        });
    }

    updateLanguageMappings();

    const sourceNames = {
        'DeepL': 'DeepL',
        'PONS': 'PONS',
        'Google': 'Google',
        'Lingva': 'Lingva'
    };

    // ==================== Settings Modal ====================

    const settingsBtn = document.getElementById('settings-btn');
    const settingsModal = document.getElementById('settings-modal');
    const settingsClose = document.getElementById('settings-close');
    const settingsCancel = document.getElementById('settings-cancel');
    const settingsSave = document.getElementById('settings-save');

    function populateLanguageSelects() {
        const selects = [];
        for (let i = 1; i <= 6; i++) {
            selects.push(document.getElementById('settings-lang-' + i));
        }

        selects.forEach((select, index) => {
            select.innerHTML = '';
            // Empty first option
            const emptyOpt = document.createElement('option');
            emptyOpt.value = '';
            emptyOpt.textContent = '‚Äî Nicht belegt ‚Äî';
            select.appendChild(emptyOpt);

            Object.entries(allLanguages).forEach(([key, lang]) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = `${lang.flag} ${lang.name}`;
                select.appendChild(option);
            });
            // Set current value from settings
            if (appSettings.languages[index]) {
                select.value = appSettings.languages[index];
            } else {
                select.value = '';
            }
        });
    }

    // ==================== API Keys ====================

    async function loadApiKeys() {
        try {
            const response = await fetch('/user/api-keys');
            if (response.ok) {
                const data = await response.json();
                const keys = data.keys || {};
                const trialDays = data.trial_days_remaining || 0;

                // Update input placeholders/values
                ['deepl', 'pons', 'google'].forEach(service => {
                    const input = document.getElementById('apikey-' + service);
                    if (keys[service]) {
                        input.value = '';
                        input.placeholder = keys[service];
                        input.dataset.hasKey = 'true';
                    } else {
                        input.value = '';
                        if (trialDays > 0) {
                            input.placeholder = 'Admin-Key aktiv (noch ' + trialDays + ' Tage)';
                        } else {
                            input.placeholder = 'Kein Key';
                        }
                        input.dataset.hasKey = 'false';
                    }
                });

                // Update hint text
                const hint = document.getElementById('api-keys-hint');
                if (trialDays > 0 && trialDays < 999) {
                    hint.textContent = 'Probezeit: noch ' + trialDays + ' Tage mit Admin-Keys. Danach eigene Keys ben√∂tigt.';
                } else if (trialDays >= 999) {
                    hint.textContent = 'Admin-Konto: Admin-Keys werden immer verwendet (Fallback).';
                } else {
                    hint.textContent = 'Eigene API-Keys eintragen, um √úbersetzungsdienste zu nutzen.';
                }
            }
        } catch (e) {
            console.error('Error loading API keys:', e);
        }
    }

    async function saveApiKey(service, apiKey) {
        try {
            const response = await fetch('/user/api-keys', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ service: service, api_key: apiKey })
            });
            return response.ok;
        } catch (e) {
            console.error('Error saving API key:', e);
            return false;
        }
    }

    async function deleteApiKey(service) {
        try {
            const response = await fetch('/user/api-keys/' + service, { method: 'DELETE' });
            return response.ok;
        } catch (e) {
            console.error('Error deleting API key:', e);
            return false;
        }
    }

    // Delete button handlers
    document.querySelectorAll('.api-key-delete').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.preventDefault();
            const service = btn.dataset.service;
            if (await deleteApiKey(service)) {
                const input = document.getElementById('apikey-' + service);
                input.value = '';
                input.dataset.hasKey = 'false';
                loadApiKeys();
            }
        });
    });

    function openSettingsModal() {
        populateLanguageSelects();

        // Set checkbox states
        document.getElementById('service-deepl').checked = appSettings.translationServices['DeepL'] !== false;
        document.getElementById('service-pons').checked = appSettings.translationServices['PONS'] !== false;
        document.getElementById('service-google').checked = appSettings.translationServices['Google'] !== false;
        document.getElementById('service-lingva').checked = appSettings.translationServices['Lingva'] === true;
        document.getElementById('explain-pons').checked = appSettings.explanationServices['PONS Definition'] !== false;
        document.getElementById('explain-groq').checked = appSettings.explanationServices['Groq AI'] !== false;

        // Load API keys
        loadApiKeys();

        // Show admin link for admin users
        const adminLink = document.getElementById('admin-dashboard-link');
        if (adminLink && (currentUserId === 1 || currentUsername === 'admin')) {
            adminLink.style.display = 'inline-block';
        }

        settingsModal.style.display = 'flex';
    }

    function closeSettingsModal() {
        settingsModal.style.display = 'none';
        updateConfigWarning();
    }

    function saveSettings() {
        // Collect non-empty language selections
        const newLanguages = [];
        for (let i = 1; i <= 6; i++) {
            const val = document.getElementById('settings-lang-' + i).value;
            if (val) newLanguages.push(val);
        }

        // Require minimum 2
        if (newLanguages.length < 2) {
            alert('Bitte w√§hle mindestens 2 Sprachen aus.');
            return;
        }

        // Check for duplicates
        const uniqueLangs = new Set(newLanguages);
        if (uniqueLangs.size !== newLanguages.length) {
            alert('Bitte w√§hle verschiedene Sprachen aus (keine Duplikate).');
            return;
        }

        // Get service states
        const newTranslationServices = {
            'DeepL': document.getElementById('service-deepl').checked,
            'PONS': document.getElementById('service-pons').checked,
            'Google': document.getElementById('service-google').checked,
            'Lingva': document.getElementById('service-lingva').checked
        };

        const newExplanationServices = {
            'PONS Definition': document.getElementById('explain-pons').checked,
            'Groq AI': document.getElementById('explain-groq').checked
        };

        // Update settings
        appSettings = {
            languages: newLanguages,
            translationServices: newTranslationServices,
            explanationServices: newExplanationServices
        };

        saveSettingsToStorage(appSettings);
        updateLanguageMappings();
        updateLanguageDropdowns();
        updateCameraLangButtons();

        // Save API keys (only non-empty new values)
        const apiKeyPromises = [];
        ['deepl', 'pons', 'google'].forEach(service => {
            const input = document.getElementById('apikey-' + service);
            const val = input.value.trim();
            if (val) {
                apiKeyPromises.push(saveApiKey(service, val));
            }
        });
        if (apiKeyPromises.length > 0) {
            Promise.all(apiKeyPromises);
        }

        closeSettingsModal();
    }

    settingsBtn.addEventListener('click', openSettingsModal);
    settingsClose.addEventListener('click', closeSettingsModal);
    settingsCancel.addEventListener('click', closeSettingsModal);
    settingsSave.addEventListener('click', saveSettings);

    // Close modal when clicking outside
    settingsModal.addEventListener('click', (e) => {
        if (e.target === settingsModal) {
            closeSettingsModal();
        }
    });

    // Update language dropdown options based on settings
    function updateLanguageDropdowns() {
        const dropdown = document.getElementById('language-dropdown');
        dropdown.innerHTML = '';

        appSettings.languages.forEach(lang => {
            const langData = allLanguages[lang];
            if (langData) {
                const option = document.createElement('div');
                option.className = 'language-option';
                option.dataset.lang = lang;
                option.dataset.flag = langData.flag;
                option.innerHTML = `<span>${langData.flag}</span> ${langData.name}`;
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectedLanguage = lang;
                    localStorage.setItem(storageKey('selectedLanguage'), selectedLanguage);
                    updateLanguageDisplay(selectedLanguage);
                    dropdown.classList.remove('show');
                });
                dropdown.appendChild(option);
            }
        });

        // Update selected language if it's not in the new list
        if (!appSettings.languages.includes(selectedLanguage)) {
            selectedLanguage = appSettings.languages[0];
            localStorage.setItem(storageKey('selectedLanguage'), selectedLanguage);
        }
        updateLanguageDisplay(selectedLanguage);
    }

    // Update camera language buttons based on settings
    function updateCameraLangButtons() {
        const container = document.querySelector('.camera-lang-buttons');
        container.innerHTML = '';

        appSettings.languages.forEach(lang => {
            const langData = allLanguages[lang];
            if (langData) {
                const btn = document.createElement('button');
                btn.className = 'lang-btn';
                btn.dataset.lang = lang;
                btn.disabled = true;
                btn.textContent = langData.flag;
                btn.addEventListener('click', () => {
                    if (selectedWordsList.length > 0) {
                        selectedLanguage = lang;
                        localStorage.setItem(storageKey('selectedLanguage'), selectedLanguage);
                        updateLanguageDisplay(selectedLanguage);
                        inputText.value = selectedWordsList.join(' ');
                        closeCamera();
                        setTimeout(() => {
                            translateBtn.click();
                        }, 100);
                    }
                });
                container.appendChild(btn);
            }
        });
    }

    // Initialize dropdowns on load
    updateLanguageDropdowns();
    updateCameraLangButtons();

    // Show/hide config warning and disable translate when no languages configured
    function updateConfigWarning() {
        const needsConfig = appSettings.languages.length < 2;
        translateBtn.disabled = needsConfig;
        let warning = document.getElementById('config-warning');
        if (needsConfig) {
            if (!warning) {
                warning = document.createElement('div');
                warning.id = 'config-warning';
                warning.style.cssText = 'text-align:center;padding:1.5rem;background:var(--card-bg);border-radius:0.75rem;box-shadow:var(--shadow);color:var(--text-muted);';
                warning.innerHTML = 'Bitte zuerst in den <a href="#" id="config-warning-link" style="color:var(--primary-color);font-weight:600;">‚öôÔ∏è Einstellungen</a> mindestens 2 Sprachen ausw√§hlen.';
                translationsContainer.parentNode.insertBefore(warning, translationsContainer);
                warning.querySelector('#config-warning-link').addEventListener('click', (e) => {
                    e.preventDefault();
                    openSettingsModal();
                });
            }
        } else if (warning) {
            warning.remove();
        }
    }

    // Sync settings from DB on load, then decide if settings modal is needed
    (async function initSettings() {
        const hasLocal = localStorage.getItem(storageKey('glossariumSettings'));
        const needsSettings = !hasLocal || appSettings.languages.length < 2;

        if (needsSettings) {
            // No local settings - try to load from DB (cross-device sync)
            const dbSettings = await syncSettingsFromDB();
            if (dbSettings && dbSettings.languages && dbSettings.languages.length >= 2) {
                // Apply settings without reload
                appSettings = dbSettings;
                updateLanguageMappings();
                updateLanguageDropdowns();
                updateCameraLangButtons();
                selectedLanguage = appSettings.languages[0] || 'german';
                updateLanguageDisplay(selectedLanguage);
                updateConfigWarning();
                return;
            }
            setTimeout(() => openSettingsModal(), 300);
        } else {
            // Local settings exist - also save to DB if not yet synced
            fetch('/user/settings').then(r => r.json()).then(data => {
                if (!data.language_config) {
                    // DB has no settings yet, push local settings to DB
                    saveSettingsToStorage(appSettings);
                }
            }).catch(() => {});
        }
        updateConfigWarning();
    })();

    function updateLanguageDisplay(lang) {
        const langData = allLanguages[lang];
        if (langData) {
            selectedLanguageFlag.textContent = langData.flag;
            selectedLanguageText.textContent = langData.name;
        }
    }

    updateLanguageDisplay(selectedLanguage);

    // Toggle dropdown
    languageSelector.addEventListener('click', (e) => {
        e.stopPropagation();
        languageDropdown.classList.toggle('show');
    });

    // Note: Language options are added dynamically in updateLanguageDropdowns()

    document.addEventListener('click', () => {
        languageDropdown.classList.remove('show');
        glossaryDropdown.classList.remove('show');
    });

    // ==================== Glossary Functions ====================

    async function loadGlossaries() {
        try {
            const response = await fetch('/glossaries');
            if (response.ok) {
                glossaries = await response.json();
                renderGlossaryList();

                // Select saved glossary or default
                if (selectedGlossaryId) {
                    const found = glossaries.find(g => g.id == selectedGlossaryId);
                    if (found) {
                        updateGlossaryDisplayNames(found.name);
                    } else {
                        selectDefaultGlossary();
                    }
                } else {
                    selectDefaultGlossary();
                }
            }
        } catch (error) {
            console.error('Error loading glossaries:', error);
        }
    }

    function selectDefaultGlossary() {
        const defaultGlossary = glossaries.find(g => g.is_default);
        if (defaultGlossary) {
            selectedGlossaryId = defaultGlossary.id;
            updateGlossaryDisplayNames(defaultGlossary.name);
            localStorage.setItem(storageKey('selectedGlossaryId'), selectedGlossaryId);
        }
    }

    function updateGlossaryDisplayNames(name) {
        selectedGlossaryName.textContent = name;
        recentGlossaryName.textContent = name;
        exportGlossaryName.textContent = name;
    }

    function renderGlossaryList() {
        glossaryList.innerHTML = '';
        glossaries.forEach(g => {
            const option = document.createElement('div');
            option.className = 'glossary-option' + (g.id == selectedGlossaryId ? ' selected' : '');
            option.dataset.id = g.id;
            option.innerHTML = `
                <span class="glossary-name">${g.name}</span>
                <span class="glossary-count">${g.entry_count}</span>
            `;
            option.addEventListener('click', (e) => {
                e.stopPropagation();
                selectedGlossaryId = g.id;
                updateGlossaryDisplayNames(g.name);
                localStorage.setItem(storageKey('selectedGlossaryId'), selectedGlossaryId);
                glossaryDropdown.classList.remove('show');
                renderGlossaryList();
                loadRecentEntries(); // Reload entries for new glossary
            });
            glossaryList.appendChild(option);
        });
    }

    // Toggle glossary dropdown
    glossaryMenuBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        glossaryDropdown.classList.toggle('show');
        languageDropdown.classList.remove('show');
    });

    // Create new glossary
    createGlossaryBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const name = newGlossaryInput.value.trim();
        if (!name) return;

        try {
            const response = await fetch('/glossaries', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: name })
            });

            if (response.ok) {
                const newGlossary = await response.json();
                glossaries.push(newGlossary);
                newGlossaryInput.value = '';

                // Auto-select the new glossary
                selectedGlossaryId = newGlossary.id;
                updateGlossaryDisplayNames(newGlossary.name);
                localStorage.setItem(storageKey('selectedGlossaryId'), selectedGlossaryId);

                renderGlossaryList();
            } else {
                const error = await response.json();
                alert(error.detail || 'Fehler beim Erstellen');
            }
        } catch (error) {
            console.error('Error creating glossary:', error);
        }
    });

    newGlossaryInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            createGlossaryBtn.click();
        }
        e.stopPropagation();
    });

    newGlossaryInput.addEventListener('click', (e) => {
        e.stopPropagation();
    });

    // Export glossary
    function exportGlossary(e) {
        e.preventDefault();
        const url = selectedGlossaryId ? `/glossary/export?glossary_id=${selectedGlossaryId}` : '/glossary/export';
        window.location.href = url;
    }
    exportGlossaryBtn.addEventListener('click', exportGlossary);
    exportGlossaryBtnBottom.addEventListener('click', exportGlossary);

    // Load glossaries and recent entries on page load
    loadGlossaries().then(() => {
        loadRecentEntries();
    });

    function clearFields() {
        inputText.value = '';
        translationsContainer.style.display = 'none';
        translationsContainer.innerHTML = '';
        selectionStatus.style.display = 'none';
        aiExplanationBox.style.display = 'none';
        aiExplanationContent.textContent = '';
        currentData = null;
        selections = {};
    }

    // Load recent entries from database
    async function loadRecentEntries() {
        try {
            const url = selectedGlossaryId
                ? `/glossary/recent?glossary_id=${selectedGlossaryId}`
                : '/glossary/recent';
            const response = await fetch(url);
            if (response.ok) {
                recentSaves = await response.json();
                renderRecentSaves();
            }
        } catch (error) {
            console.error('Error loading recent entries:', error);
        }
    }

    function renderRecentSaves() {
        const recentSavesContainer = document.getElementById('recent-saves');
        const recentSavesList = document.getElementById('recent-saves-list');

        if (recentSaves.length === 0) {
            recentSavesContainer.style.display = 'none';
            return;
        }

        recentSavesContainer.style.display = 'block';
        recentSavesList.innerHTML = '';

        recentSaves.forEach((save) => {
            const saveItem = document.createElement('div');
            saveItem.className = 'recent-save-item';

            let html = '';
            // Display based on current language settings - show all 4 columns from settings
            appSettings.languages.forEach(lang => {
                const langData = allLanguages[lang];
                const value = save[lang] || save.entries?.[lang] || '';
                if (value && langData) {
                    html += `<div class="save-row"><span class="flag-small">${langData.flag}</span> ${value}</div>`;
                }
            });

            // Fallback: if no settings-based data, show any available data
            if (!html) {
                if (save.spanish) html += `<div class="save-row"><span class="flag-small">üá™üá∏</span> ${save.spanish}</div>`;
                if (save.german) html += `<div class="save-row"><span class="flag-small">üá©üá™</span> ${save.german}</div>`;
                if (save.polish) html += `<div class="save-row"><span class="flag-small">üáµüá±</span> ${save.polish}</div>`;
                if (save.english) html += `<div class="save-row"><span class="flag-small">üá¨üáß</span> ${save.english}</div>`;
            }

            saveItem.innerHTML = html;
            recentSavesList.appendChild(saveItem);
        });
    }

    function updateRecentSaves(entry) {
        recentSaves.unshift(entry);
        if (recentSaves.length > 4) {
            recentSaves.pop();
        }
        renderRecentSaves();
    }

    function checkAndSave() {
        const targetLangs = Object.keys(currentData.translations);
        const selectedCount = Object.keys(selections).length;

        selectionCount.textContent = `${selectedCount}/${targetLangs.length}`;

        if (selectedCount === targetLangs.length) {
            // All selected - auto save
            saveToGlossary();
        }
    }

    async function saveToGlossary() {
        // Build slot-based save data using current language settings
        const slots = appSettings.languages.map((lang) => {
            if (lang === currentData.source_language) {
                return currentData.source_text;
            }
            return selections[lang] || currentData.source_text;
        });

        const saveData = {
            language_config: appSettings.languages,
            glossary_id: selectedGlossaryId ? parseInt(selectedGlossaryId) : null
        };

        // Set slot1 through slot6
        slots.forEach((val, i) => {
            saveData['slot' + (i + 1)] = val;
        });

        try {
            const response = await fetch('/glossary/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(saveData),
            });

            if (response.ok) {
                // Create display data for recent saves
                const displayData = {};
                appSettings.languages.forEach((lang, i) => {
                    displayData[lang] = slots[i];
                });
                updateRecentSaves(displayData);
                clearFields();
                // Reload glossaries to update count
                loadGlossaries();
            }
        } catch (error) {
            console.error('Error saving:', error);
        }
    }

    function renderTranslations(data) {
        currentData = data;
        selections = {};
        translationsContainer.innerHTML = '';
        translationsContainer.style.display = 'grid';
        selectionStatus.style.display = 'block';

        const targetLangs = Object.keys(data.translations);
        // Set dynamic grid class based on target count (1-5)
        const gridCount = Math.min(Math.max(targetLangs.length, 1), 5);
        translationsContainer.className = 'translations-grid-' + gridCount;

        selectionCount.textContent = `0/${targetLangs.length}`;

        for (const [lang, sources] of Object.entries(data.translations)) {
            const card = document.createElement('div');
            card.className = 'translation-card';
            card.dataset.lang = lang;

            const langData = allLanguages[lang] || { flag: 'üåê', name: lang };
            const flag = langData.flag;
            const langName = langData.name;

            let optionsHtml = '';

            for (const [sourceKey, translation] of Object.entries(sources)) {
                if (translation === '[Error]' || translation === '[No API Key]') continue;

                // Show limit reached message
                if (translation === '[Limit]') {
                    optionsHtml += `
                        <div class="translation-option limit-option" data-source="${sourceKey}">
                            <span class="source-badge limit-badge">${sourceKey}</span>
                            <span class="translation-text limit-text">Limit erreicht</span>
                        </div>
                    `;
                    continue;
                }

                // For PONS, split by comma to show alternatives separately
                if (sourceKey === 'PONS' && translation.includes(',')) {
                    const alternatives = translation.split(',').map(t => t.trim());
                    alternatives.forEach((alt, idx) => {
                        if (alt) {
                            optionsHtml += `
                                <div class="translation-option pons-option" data-source="PONS" data-translation="${alt}">
                                    <span class="source-badge pons-badge">PONS</span>
                                    <span class="translation-text">${alt}</span>
                                </div>
                            `;
                        }
                    });
                } else {
                    optionsHtml += `
                        <div class="translation-option" data-source="${sourceKey}" data-translation="${translation}">
                            <span class="source-badge">${sourceKey}</span>
                            <span class="translation-text">${translation}</span>
                        </div>
                    `;
                }
            }

            card.innerHTML = `
                <div class="card-header">
                    <span class="flag">${flag}</span>
                    <h3>${langName}</h3>
                </div>
                <div class="card-content">
                    ${optionsHtml}
                    <div class="custom-input-section">
                        <div class="custom-input-wrapper">
                            <input type="text" class="custom-translation-input" data-lang="${lang}" placeholder="Eigene Eingabe...">
                            <button class="custom-input-btn" data-lang="${lang}" title="Eigene Eingabe verwenden">‚úì</button>
                        </div>
                    </div>
                </div>
            `;

            // Add click handlers for translation options
            card.querySelectorAll('.translation-option').forEach(option => {
                option.addEventListener('click', () => {
                    // Remove previous selection in this card
                    card.querySelectorAll('.translation-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    // Clear custom input selection
                    card.querySelector('.custom-input-wrapper').classList.remove('selected');
                    card.querySelector('.custom-translation-input').classList.remove('selected');

                    // Select this option
                    option.classList.add('selected');
                    selections[lang] = option.dataset.translation;

                    checkAndSave();
                });
            });

            // Add handler for custom input button
            const customBtn = card.querySelector('.custom-input-btn');
            const customInput = card.querySelector('.custom-translation-input');

            customBtn.addEventListener('click', () => {
                const customValue = customInput.value.trim();
                if (!customValue) {
                    alert('Bitte gib einen Text ein');
                    return;
                }

                // Remove previous selection in this card
                card.querySelectorAll('.translation-option').forEach(opt => {
                    opt.classList.remove('selected');
                });

                // Mark custom input as selected
                card.querySelector('.custom-input-wrapper').classList.add('selected');
                customInput.classList.add('selected');

                selections[lang] = customValue;
                checkAndSave();
            });

            // Allow Enter key in custom input
            customInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    customBtn.click();
                }
            });

            translationsContainer.appendChild(card);
        }
    }

    translateBtn.addEventListener('click', async () => {
        const text = inputText.value.trim();
        if (!text) {
            alert('Please enter some text to translate');
            return;
        }

        translateBtn.disabled = true;
        translateBtn.textContent = 'Translating...';

        try {
            // Build target languages (all except source)
            const targetLangs = appSettings.languages.filter(l => l !== selectedLanguage);

            const response = await fetch('/translate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    text: text,
                    source_language: selectedLanguage,
                    target_languages: targetLangs,
                    enabled_services: appSettings.translationServices,
                    explanation_services: appSettings.explanationServices
                }),
            });

            if (response.ok) {
                const data = await response.json();

                // Update selected language
                if (data.source_language && data.source_language !== 'auto') {
                    selectedLanguage = data.source_language;
                    localStorage.setItem(storageKey('selectedLanguage'), selectedLanguage);
                    updateLanguageDisplay(selectedLanguage);
                }

                renderTranslations(data);

                // Show PONS definition if available
                if (data.ai_explanation && data.ai_explanation.trim()) {
                    aiExplanationContent.textContent = data.ai_explanation;
                    aiExplanationBox.style.display = 'block';
                } else {
                    aiExplanationBox.style.display = 'none';
                }

                // Show Groq explanation if available
                if (data.groq_explanation && data.groq_explanation.trim()) {
                    groqExplanationContent.textContent = data.groq_explanation;
                    groqExplanationBox.style.display = 'block';
                } else {
                    groqExplanationBox.style.display = 'none';
                }
            } else {
                alert('Translation failed. Please try again.');
            }
        } catch (error) {
            console.error('Error:', error);
            alert('An error occurred. Please try again.');
        } finally {
            translateBtn.disabled = false;
            translateBtn.textContent = 'Translate';
        }
    });

    inputText.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            translateBtn.click();
        }
    });

    // ==================== Camera OCR ====================

    const cameraBtn = document.getElementById('camera-btn');
    const cameraOverlay = document.getElementById('camera-overlay');
    const cameraClose = document.getElementById('camera-close');
    const cameraVideo = document.getElementById('camera-video');
    const cameraCanvas = document.getElementById('camera-canvas');
    const cameraCapture = document.getElementById('camera-capture');
    const cameraStatus = document.getElementById('camera-status');
    const scannedWordsContainer = document.getElementById('scanned-words');
    const selectedPreviewText = document.getElementById('selected-preview-text');
    const scanFrame = document.getElementById('scan-frame');
    const cameraContainer = document.querySelector('.camera-container');

    let cameraStream = null;
    let scannedWordsList = [];
    let selectedWordsList = [];
    let tesseractWorker = null;
    let currentZoom = 1;
    let videoTrack = null;

    // Initialize Tesseract worker
    async function initTesseract() {
        if (!tesseractWorker) {
            cameraStatus.textContent = 'Lade Texterkennung...';
            tesseractWorker = await Tesseract.createWorker('deu+eng+spa+pol+fra+ita+por+nld+rus');
            cameraStatus.textContent = '';
        }
        return tesseractWorker;
    }

    // Update selected words preview
    function updateSelectedPreview() {
        const cameraLangButtons = document.querySelectorAll('.camera-lang-buttons .lang-btn');
        if (selectedWordsList.length === 0) {
            selectedPreviewText.textContent = '---';
            cameraLangButtons.forEach(btn => btn.disabled = true);
        } else {
            selectedPreviewText.textContent = selectedWordsList.join(' ');
            cameraLangButtons.forEach(btn => btn.disabled = false);
        }
    }

    // Note: Camera language button click handlers are added dynamically in updateCameraLangButtons()

    // Render scanned words as clickable chips
    function renderScannedWords() {
        scannedWordsContainer.innerHTML = '';
        scannedWordsList.forEach((word, index) => {
            const chip = document.createElement('span');
            chip.className = 'word-chip';
            chip.textContent = word;
            chip.dataset.index = index;

            // Check if already selected
            if (selectedWordsList.includes(word)) {
                chip.classList.add('selected');
            }

            chip.addEventListener('click', () => {
                if (chip.classList.contains('selected')) {
                    chip.classList.remove('selected');
                    selectedWordsList = selectedWordsList.filter(w => w !== word);
                } else {
                    chip.classList.add('selected');
                    selectedWordsList.push(word);
                }
                updateSelectedPreview();
            });

            scannedWordsContainer.appendChild(chip);
        });
    }

    // Pinch-zoom handling for camera
    let initialDistance = 0;
    let lastZoom = 1;

    function getDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function handleTouchStart(e) {
        if (e.touches.length === 2) {
            e.preventDefault();
            initialDistance = getDistance(e.touches);
            lastZoom = currentZoom;
        }
    }

    function handleTouchMove(e) {
        if (e.touches.length === 2) {
            e.preventDefault();
            const currentDistance = getDistance(e.touches);
            const scale = currentDistance / initialDistance;
            currentZoom = Math.min(Math.max(lastZoom * scale, 1), 5); // Limit zoom 1x-5x

            // Try hardware zoom first, fallback to CSS transform
            if (videoTrack) {
                const capabilities = videoTrack.getCapabilities();
                if (capabilities.zoom) {
                    const minZoom = capabilities.zoom.min;
                    const maxZoom = capabilities.zoom.max;
                    const hwZoom = minZoom + (currentZoom - 1) / 4 * (maxZoom - minZoom);
                    videoTrack.applyConstraints({ advanced: [{ zoom: hwZoom }] }).catch(() => {});
                }
            }
            // CSS fallback/enhancement
            cameraVideo.style.transform = `scale(${currentZoom})`;
        }
    }

    function handleTouchEnd(e) {
        if (e.touches.length < 2) {
            initialDistance = 0;
        }
    }

    // Open camera
    cameraBtn.addEventListener('click', async () => {
        try {
            cameraOverlay.style.display = 'flex';
            cameraStatus.textContent = 'Kamera wird gestartet...';
            scannedWordsContainer.innerHTML = '<span class="no-words">---</span>';
            scannedWordsList = [];
            selectedWordsList = [];
            currentZoom = 1;
            cameraVideo.style.transform = 'scale(1)';
            updateSelectedPreview();

            // Request camera with preference for back camera on mobile
            const constraints = {
                video: {
                    facingMode: { ideal: 'environment' },
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };

            cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
            cameraVideo.srcObject = cameraStream;

            // Get video track for hardware zoom
            videoTrack = cameraStream.getVideoTracks()[0];

            // Add pinch-zoom listeners
            cameraContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
            cameraContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
            cameraContainer.addEventListener('touchend', handleTouchEnd);

            cameraStatus.textContent = 'Richte den Rahmen auf das Wort. Zoom mit 2 Fingern.';

            // Pre-load Tesseract
            initTesseract();
        } catch (error) {
            console.error('Camera error:', error);
            cameraStatus.textContent = 'Kamera-Zugriff verweigert. Bitte erlaube den Zugriff in den Einstellungen.';
        }
    });

    // Close camera
    function closeCamera() {
        // Remove zoom listeners
        cameraContainer.removeEventListener('touchstart', handleTouchStart);
        cameraContainer.removeEventListener('touchmove', handleTouchMove);
        cameraContainer.removeEventListener('touchend', handleTouchEnd);

        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
            cameraStream = null;
        }
        videoTrack = null;
        cameraVideo.srcObject = null;
        cameraVideo.style.transform = 'scale(1)';
        currentZoom = 1;
        cameraOverlay.style.display = 'none';
        scannedWordsList = [];
        selectedWordsList = [];
    }

    cameraClose.addEventListener('click', closeCamera);

    // Capture and OCR - only scan the frame area
    cameraCapture.addEventListener('click', async () => {
        if (!cameraStream) return;

        cameraStatus.textContent = 'Erkenne Text...';
        cameraCapture.disabled = true;

        try {
            const video = cameraVideo;
            const canvas = cameraCanvas;

            // Get frame position relative to video
            const videoRect = video.getBoundingClientRect();
            const frameRect = scanFrame.getBoundingClientRect();

            // Calculate frame position in video coordinates
            const scaleX = video.videoWidth / videoRect.width;
            const scaleY = video.videoHeight / videoRect.height;

            const frameX = (frameRect.left - videoRect.left) * scaleX;
            const frameY = (frameRect.top - videoRect.top) * scaleY;
            const frameW = frameRect.width * scaleX;
            const frameH = frameRect.height * scaleY;

            // Create canvas with only the frame area
            canvas.width = frameW;
            canvas.height = frameH;
            const ctx = canvas.getContext('2d');

            // Draw only the frame portion
            ctx.drawImage(video, frameX, frameY, frameW, frameH, 0, 0, frameW, frameH);

            // Get image data
            const imageData = canvas.toDataURL('image/png');

            // Run OCR on cropped image
            const worker = await initTesseract();
            const result = await worker.recognize(imageData);

            // Margin in pixels - words touching edge are excluded
            const margin = 5;
            const canvasW = canvas.width;
            const canvasH = canvas.height;

            // Get all recognized words that are FULLY within the frame
            const words = result.data.words
                .filter(w => {
                    // Check confidence and length
                    if (w.confidence < 50 || w.text.trim().length < 2) return false;
                    // Check if word is fully inside (not cut off at edges)
                    const bbox = w.bbox;
                    if (bbox.x0 < margin || bbox.y0 < margin) return false;
                    if (bbox.x1 > canvasW - margin || bbox.y1 > canvasH - margin) return false;
                    return true;
                })
                .map(w => w.text.replace(/[^\w\s√§√∂√º√Ñ√ñ√ú√ü√°√©√≠√≥√∫√±-]/gi, '').trim())
                .filter(w => w.length > 0);

            if (words.length > 0) {
                // Add new words to list (avoid duplicates)
                words.forEach(word => {
                    if (!scannedWordsList.includes(word)) {
                        scannedWordsList.push(word);
                    }
                });
                renderScannedWords();
                cameraStatus.textContent = 'Tippe auf W√∂rter zum Ausw√§hlen. Erneut scannen f√ºr mehr.';
            } else {
                if (scannedWordsList.length === 0) {
                    scannedWordsContainer.innerHTML = '<span class="no-words">(kein Text erkannt)</span>';
                }
                cameraStatus.textContent = 'Kein Text erkannt. Rahmen n√§her an das Wort richten.';
            }
        } catch (error) {
            console.error('OCR error:', error);
            cameraStatus.textContent = 'Fehler bei der Texterkennung. Versuche es erneut.';
        } finally {
            cameraCapture.disabled = false;
        }
    });

</script>
{% endblock %}
